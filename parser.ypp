%{

#include <iostream>
#include <memory>
#include "hw3_output.hpp"
#include "Node.hpp"
/*
#include "SymbolTable.hpp"
#include "SyntaxExceptions.hpp"
*/

using namespace std;


void yyerror(const char*);

extern int yylex();
extern int yylineno;
/*
SymbolTable symbol_table;
*/

%}

// normal tokens
%token VOID
%token INT
%token STRING
%token BYTE
%token B
%token BOOL
%token TRUE
%token FALSE
%token NUM
%token RETURN
%token ELSE
%token IF
%token WHILE
%token BREAK
%token CONTINUE
%token SC
%token COMMA
%token LBRACE
%token RBRACE
%token ID

// dangling else
%precedence LPAREN RPAREN
%precedence ELSE

// associative tokens, from low priority to high priority
%right ASSIGN

%left OR
%left AND
// TODO: change all occurances of RELOP to RELOP + EQUALOP
%left EQUALOP
%nonassoc RELOP

// TODO: change all occurances of plus,minus,div,mul to BINOP
%left PLUS MINUS
%left DIV MUL

%left NOT

%token LPAREN
%token RPAREN


%%
Program: 		Funcs {}
;
Funcs:			/*epsilon*/ {}
			|	FuncDecl Funcs {}
;
FuncDecl:		RetType ID LPAREN Formals RPAREN LBRACE Statements RBRACE 
				{} //TODO: Push function symbol to global function symbol table
;
RetType:		Type {}
;
RetType:		VOID {}
;
Formals:		/*epsilon*/ {}
			|	FormalsList {}
;
FormalsList:	FormalDecl {}
			|	FormalDecl COMMA FormalsList {}
;
FormalDecl:		Type ID {}
;
Statements:		Statement {}
			|	Statements Statement {}
;
Statement:		LBRACE Statements RBRACE {}	
			| 	Type ID SC {}
			|	Type ID ASSIGN Exp SC {}
			|	ID ASSIGN Exp SC {}
			|	Call SC {}
			|	RETURN SC {}
			|	RETURN Exp SC {}
			|	IF LPAREN Exp RPAREN Statement ELSE Statement 
				{}
			|	IF LPAREN Exp RPAREN Statement {}
			|	WHILE LPAREN Exp RPAREN Statement ELSE Statement 
				{}
			|   WHILE LPAREN Exp RPAREN Statement {}
			|	BREAK SC {}
			|	CONTINUE SC {}
;
Call:			ID LPAREN ExpList RPAREN {}
			|	ID LPAREN RPAREN {}
;
ExpList:		Exp {}
			|	Exp COMMA ExpList {}
;
Type:			INT {}
			|	BYTE {}
			|	BOOL {}
;
Exp:			LPAREN Exp RPAREN {$$ = new Exp(($2)->getType());}
			|	Exp PLUS Exp {
				checkNumValue($1);
				checkNumValue($3);
				$$ = getNumValue($1, $3);
			}
			|	Exp MINUS Exp {
				checkNumValue($1);
				checkNumValue($3);
				$$ = getNumValue($1, $3);
			}
			|	Exp MUL Exp {
				checkNumValue($1);
				checkNumValue($3);
				$$ = getNumValue($1, $3);
			}
			|	Exp DIV Exp {
				checkNumValue($1);
				checkNumValue($3);
				$$ = getNumValue($1, $3);
			}
			|	ID {//TODO: Check ID Exists in symbol table, and determine type of expression according to ID type}
			|	Call {//TODO: Check FuncID Exists in symbol table, and arglist is valid determine type of expression according to retType}
			|	NUM {$$ = new Exp(($1)->getType();)} // Semantic check - make sure that
			|	NUM B {checkByteSize(); $$ = new Exp(TypeN::BYTE);}
			|	STRING {$$ = new Exp(TypeN::STRING);}
			|	TRUE {$$ = new Exp(TypeN::BOOL);}
			|	FALSE {$$ = new Exp(TypeN::BOOL);}
			|	NOT Exp {checkBoolValue($2); $$ = new Exp(TypeN::BOOL);}
			|	Exp AND Exp {checkBoolValue($1); checkBoolValue($3); $$ = new Exp(TypeN::BOOL);}
			|	Exp OR Exp {checkBoolValue($1); checkBoolValue($3); $$ = new Exp(TypeN::BOOL);}
			|	Exp RELOP Exp {checkNumValue($1); checkNumValue($3); $$ = new Exp(TypeN::BOOL);}
			|	Exp EQUALOP Exp {checkNumValue($1); checkNumValue($3); $$ = new Exp(TypeN::BOOL);}
;

%%

void yyerror(const char* msg) {
     output::errorSyn(yylineno);
	 exit(0);
}

int main() {
	return yyparse();
	/*
	int value = -1;
	try {
		value = yyparse();
		symbol_table.endGlobalScope();
	}	catch (const errorUndefException& e) {
		errorUndef(yylineno, e.getID());
		exit(0);
	}	catch (const errorDefException& e) {
		errorDef(yylineno, e.getID());
		exit(0);
	}	catch(const errorUndefFuncException& e) {
		errorUndefFunc(yylineno, e.getID());
		exit(0);
	}	catch (const errorMismatchException& e) {
		errorMismatch(yylineno);
		exit(0);
	}	catch (const errorPrototypeMismatchException& e) {
		errorPrototypeMismatch(yylineno, e.getID(), e.getArgTypes());
		exit(0);
	}	catch (const errorUnexpectedBreakException& e) {
		errorUnexpectedBreak(yylineno);
		exit(0);
	} 	catch (const errorUnexpectedContinueException& e) {
		errorUnexpectedContinue(yylineno);
		exit(0);
	}	catch (const errorMainMissingException& e) {
		errorMainMissing();
		exit(0);
	} 	catch(catch errorByteTooLargeException& e) {
		errorByteTooLarge(yylineno, e.getValue());
		exit(0);
	}
	return value;
	*/
}